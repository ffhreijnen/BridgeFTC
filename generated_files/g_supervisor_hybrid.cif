group LTS:
  automaton button_on:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  group presigns:
    group ps1:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.ps1_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group ps2:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.ps2_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group ps3:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.ps3_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group ps4:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.ps4_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group ps5:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.ps5_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group ps6:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.ps6_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
  end
  group stopsigns:
    group stop1:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s1_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group stop2:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s2_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group stop3:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s3_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group stop4:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s4_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group stop5:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s5_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group stop6:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s6_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group stop7:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s7_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
    group stop8:
      uncontrollable u_on;
      uncontrollable u_off;
      controllable c_on;
      controllable c_off;
      alg bool fault = FTC.D.s8_f;
      automaton A:
        disc bool o = false;
        location off:
          initial;
          edge c_on do o := true goto on;
          edge u_off;
        location on:
          edge c_off do o := false goto off;
          edge u_on when not fault;
          edge u_off when fault;
      end
      automaton S:
        disc bool o = false;
        location off:
          initial;
          edge u_on do o := true goto on;
        location on:
          edge u_off do o := false goto off;
      end
    end
  end
end
group barriers:
  group barrier1:
    uncontrollable u_closed_on;
    uncontrollable u_closed_off;
    uncontrollable u_open_on;
    uncontrollable u_open_off;
    controllable c_open;
    controllable c_close;
    controllable c_stop;
    alg bool fault = FTC.D.bar1_f;
    automaton A:
      disc bool o = false;
      disc bool c = false;
      cont t = 0.0 der if opening or closing: 1.0 else 0.0 end;
      location stopped:
        initial;
        edge c_open do o := true, c := false goto opening;
        edge c_close do o := false, c := true goto closing;
      location opening:
        edge c_stop do o := true, c := false, t := 0.0 goto stopped;
        edge u_open_on when t >= 2.0 and not fault;
        edge u_closed_off when not fault;
      location closing:
        edge c_stop do o := false, c := false, t := 0.0 goto stopped;
        edge u_closed_on when t >= 2.0;
        edge u_open_off;
    end
    automaton S:
      disc bool c = false;
      disc bool o = true;
      location open:
        initial;
        edge u_open_off do c := false, o := false goto between;
      location between:
        edge u_open_on do c := false, o := true goto open;
        edge u_closed_on do c := true, o := false goto closed;
      location closed:
        edge u_closed_off do c := false, o := false goto between;
    end
  end
  group barrier2:
    uncontrollable u_closed_on;
    uncontrollable u_closed_off;
    uncontrollable u_open_on;
    uncontrollable u_open_off;
    controllable c_open;
    controllable c_close;
    controllable c_stop;
    alg bool fault = FTC.D.bar2_f;
    automaton A:
      disc bool o = false;
      disc bool c = false;
      cont t = 0.0 der if opening or closing: 1.0 else 0.0 end;
      location stopped:
        initial;
        edge c_open do o := true, c := false goto opening;
        edge c_close do o := false, c := true goto closing;
      location opening:
        edge c_stop do o := true, c := false, t := 0.0 goto stopped;
        edge u_open_on when t >= 2.0 and not fault;
        edge u_closed_off when not fault;
      location closing:
        edge c_stop do o := false, c := false, t := 0.0 goto stopped;
        edge u_closed_on when t >= 2.0;
        edge u_open_off;
    end
    automaton S:
      disc bool c = false;
      disc bool o = true;
      location open:
        initial;
        edge u_open_off do c := false, o := false goto between;
      location between:
        edge u_open_on do c := false, o := true goto open;
        edge u_closed_on do c := true, o := false goto closed;
      location closed:
        edge u_closed_off do c := false, o := false goto between;
    end
  end
  group barrier3:
    uncontrollable u_closed_on;
    uncontrollable u_closed_off;
    uncontrollable u_open_on;
    uncontrollable u_open_off;
    controllable c_open;
    controllable c_close;
    controllable c_stop;
    alg bool fault = FTC.D.bar3_f;
    automaton A:
      disc bool o = false;
      disc bool c = false;
      cont t = 0.0 der if opening or closing: 1.0 else 0.0 end;
      location stopped:
        initial;
        edge c_open do o := true, c := false goto opening;
        edge c_close do o := false, c := true goto closing;
      location opening:
        edge c_stop do o := true, c := false, t := 0.0 goto stopped;
        edge u_open_on when t >= 2.0 and not fault;
        edge u_closed_off when not fault;
      location closing:
        edge c_stop do o := false, c := false, t := 0.0 goto stopped;
        edge u_closed_on when t >= 2.0;
        edge u_open_off;
    end
    automaton S:
      disc bool c = false;
      disc bool o = true;
      location open:
        initial;
        edge u_open_off do c := false, o := false goto between;
      location between:
        edge u_open_on do c := false, o := true goto open;
        edge u_closed_on do c := true, o := false goto closed;
      location closed:
        edge u_closed_off do c := false, o := false goto between;
    end
  end
  group barrier4:
    uncontrollable u_closed_on;
    uncontrollable u_closed_off;
    uncontrollable u_open_on;
    uncontrollable u_open_off;
    controllable c_open;
    controllable c_close;
    controllable c_stop;
    alg bool fault = FTC.D.bar4_f;
    automaton A:
      disc bool o = false;
      disc bool c = false;
      cont t = 0.0 der if opening or closing: 1.0 else 0.0 end;
      location stopped:
        initial;
        edge c_open do o := true, c := false goto opening;
        edge c_close do o := false, c := true goto closing;
      location opening:
        edge c_stop do o := true, c := false, t := 0.0 goto stopped;
        edge u_open_on when t >= 2.0 and not fault;
        edge u_closed_off when not fault;
      location closing:
        edge c_stop do o := false, c := false, t := 0.0 goto stopped;
        edge u_closed_on when t >= 2.0;
        edge u_open_off;
    end
    automaton S:
      disc bool c = false;
      disc bool o = true;
      location open:
        initial;
        edge u_open_off do c := false, o := false goto between;
      location between:
        edge u_open_on do c := false, o := true goto open;
        edge u_closed_on do c := true, o := false goto closed;
      location closed:
        edge u_closed_off do c := false, o := false goto between;
    end
  end
  group barrier5:
    uncontrollable u_closed_on;
    uncontrollable u_closed_off;
    uncontrollable u_open_on;
    uncontrollable u_open_off;
    controllable c_open;
    controllable c_close;
    controllable c_stop;
    alg bool fault = FTC.D.bar5_f;
    automaton A:
      disc bool o = false;
      disc bool c = false;
      cont t = 0.0 der if opening or closing: 1.0 else 0.0 end;
      location stopped:
        initial;
        edge c_open do o := true, c := false goto opening;
        edge c_close do o := false, c := true goto closing;
      location opening:
        edge c_stop do o := true, c := false, t := 0.0 goto stopped;
        edge u_open_on when t >= 2.0 and not fault;
        edge u_closed_off when not fault;
      location closing:
        edge c_stop do o := false, c := false, t := 0.0 goto stopped;
        edge u_closed_on when t >= 2.0;
        edge u_open_off;
    end
    automaton S:
      disc bool c = false;
      disc bool o = true;
      location open:
        initial;
        edge u_open_off do c := false, o := false goto between;
      location between:
        edge u_open_on do c := false, o := true goto open;
        edge u_closed_on do c := true, o := false goto closed;
      location closed:
        edge u_closed_off do c := false, o := false goto between;
    end
  end
  group barrier6:
    uncontrollable u_closed_on;
    uncontrollable u_closed_off;
    uncontrollable u_open_on;
    uncontrollable u_open_off;
    controllable c_open;
    controllable c_close;
    controllable c_stop;
    alg bool fault = FTC.D.bar6_f;
    automaton A:
      disc bool o = false;
      disc bool c = false;
      cont t = 0.0 der if opening or closing: 1.0 else 0.0 end;
      location stopped:
        initial;
        edge c_open do o := true, c := false goto opening;
        edge c_close do o := false, c := true goto closing;
      location opening:
        edge c_stop do o := true, c := false, t := 0.0 goto stopped;
        edge u_open_on when t >= 2.0 and not fault;
        edge u_closed_off when not fault;
      location closing:
        edge c_stop do o := false, c := false, t := 0.0 goto stopped;
        edge u_closed_on when t >= 2.0;
        edge u_open_off;
    end
    automaton S:
      disc bool c = false;
      disc bool o = true;
      location open:
        initial;
        edge u_open_off do c := false, o := false goto between;
      location between:
        edge u_open_on do c := false, o := true goto open;
        edge u_closed_on do c := true, o := false goto closed;
      location closed:
        edge u_closed_off do c := false, o := false goto between;
    end
  end
  automaton button_close_entering:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_stop_entering:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_open_entering:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_close_leaving:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_stop_leaving:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_open_leaving:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_close_slow:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_stop_slow:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_open_slow:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
end
group shipping_signs:
  group upstream:
    automaton button_red:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    automaton button_redgreen:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    automaton button_green:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    automaton button_redred:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    group N:
      uncontrollable u_red_off;
      uncontrollable u_red_on;
      uncontrollable u_green_off;
      uncontrollable u_green_on;
      uncontrollable u_red2_on;
      uncontrollable u_red2_off;
      controllable c_red;
      controllable c_green;
      controllable c_redgreen;
      controllable c_redred;
      automaton A:
        disc bool r = true;
        disc bool g = false;
        disc bool s = false;
        location red:
          initial;
          edge c_redgreen do r := true, g := false, s := false goto redgreen;
          edge c_redred do r := true, g := false, s := true goto redred;
          edge u_red_on, u_green_off, u_red2_off;
        location green:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_off, u_green_on, u_red2_off;
        location redgreen:
          edge c_red do r := true, g := false, s := false goto red;
          edge c_green do r := false, g := true, s := false goto green;
          edge u_red_on, u_green_on, u_red2_off;
        location redred:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_on, u_green_off, u_red2_on;
      end
      automaton S_R:
        disc bool o = init_on;
        alg bool init_on = true;
        location off:
          initial not init_on;
          edge u_red_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red_off do o := false goto off;
      end
      automaton S_G:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_green_on do o := true goto on;
        location on:
          initial init_on;
          edge u_green_off do o := false goto off;
      end
      automaton S_S:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_red2_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red2_off do o := false goto off;
      end
    end
    group S:
      uncontrollable u_red_off;
      uncontrollable u_red_on;
      uncontrollable u_green_off;
      uncontrollable u_green_on;
      uncontrollable u_red2_on;
      uncontrollable u_red2_off;
      controllable c_red;
      controllable c_green;
      controllable c_redgreen;
      controllable c_redred;
      automaton A:
        disc bool r = true;
        disc bool g = false;
        disc bool s = false;
        location red:
          initial;
          edge c_redgreen do r := true, g := false, s := false goto redgreen;
          edge c_redred do r := true, g := false, s := true goto redred;
          edge u_red_on, u_green_off, u_red2_off;
        location green:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_off, u_green_on, u_red2_off;
        location redgreen:
          edge c_red do r := true, g := false, s := false goto red;
          edge c_green do r := false, g := true, s := false goto green;
          edge u_red_on, u_green_on, u_red2_off;
        location redred:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_on, u_green_off, u_red2_on;
      end
      automaton S_R:
        disc bool o = init_on;
        alg bool init_on = true;
        location off:
          initial not init_on;
          edge u_red_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red_off do o := false goto off;
      end
      automaton S_G:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_green_on do o := true goto on;
        location on:
          initial init_on;
          edge u_green_off do o := false goto off;
      end
      automaton S_S:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_red2_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red2_off do o := false goto off;
      end
    end
  end
  group downstream:
    automaton button_red:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    automaton button_redgreen:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    automaton button_green:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    automaton button_redred:
      uncontrollable u_pushed;
      uncontrollable u_released;
      location released:
        initial;
        edge u_pushed goto pushed;
      location pushed:
        edge u_released goto released;
    end
    group N:
      uncontrollable u_red_off;
      uncontrollable u_red_on;
      uncontrollable u_green_off;
      uncontrollable u_green_on;
      uncontrollable u_red2_on;
      uncontrollable u_red2_off;
      controllable c_red;
      controllable c_green;
      controllable c_redgreen;
      controllable c_redred;
      automaton A:
        disc bool r = true;
        disc bool g = false;
        disc bool s = false;
        location red:
          initial;
          edge c_redgreen do r := true, g := false, s := false goto redgreen;
          edge c_redred do r := true, g := false, s := true goto redred;
          edge u_red_on, u_green_off, u_red2_off;
        location green:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_off, u_green_on, u_red2_off;
        location redgreen:
          edge c_red do r := true, g := false, s := false goto red;
          edge c_green do r := false, g := true, s := false goto green;
          edge u_red_on, u_green_on, u_red2_off;
        location redred:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_on, u_green_off, u_red2_on;
      end
      automaton S_R:
        disc bool o = init_on;
        alg bool init_on = true;
        location off:
          initial not init_on;
          edge u_red_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red_off do o := false goto off;
      end
      automaton S_G:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_green_on do o := true goto on;
        location on:
          initial init_on;
          edge u_green_off do o := false goto off;
      end
      automaton S_S:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_red2_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red2_off do o := false goto off;
      end
    end
    group S:
      uncontrollable u_red_off;
      uncontrollable u_red_on;
      uncontrollable u_green_off;
      uncontrollable u_green_on;
      uncontrollable u_red2_on;
      uncontrollable u_red2_off;
      controllable c_red;
      controllable c_green;
      controllable c_redgreen;
      controllable c_redred;
      automaton A:
        disc bool r = true;
        disc bool g = false;
        disc bool s = false;
        location red:
          initial;
          edge c_redgreen do r := true, g := false, s := false goto redgreen;
          edge c_redred do r := true, g := false, s := true goto redred;
          edge u_red_on, u_green_off, u_red2_off;
        location green:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_off, u_green_on, u_red2_off;
        location redgreen:
          edge c_red do r := true, g := false, s := false goto red;
          edge c_green do r := false, g := true, s := false goto green;
          edge u_red_on, u_green_on, u_red2_off;
        location redred:
          edge c_red do r := true, g := false, s := false goto red;
          edge u_red_on, u_green_off, u_red2_on;
      end
      automaton S_R:
        disc bool o = init_on;
        alg bool init_on = true;
        location off:
          initial not init_on;
          edge u_red_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red_off do o := false goto off;
      end
      automaton S_G:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_green_on do o := true goto on;
        location on:
          initial init_on;
          edge u_green_off do o := false goto off;
      end
      automaton S_S:
        disc bool o = init_on;
        alg bool init_on = false;
        location off:
          initial not init_on;
          edge u_red2_on do o := true goto on;
        location on:
          initial init_on;
          edge u_red2_off do o := false goto off;
      end
    end
  end
end
group bridgedeck:
  uncontrollable u_open_on;
  uncontrollable u_open_off;
  uncontrollable u_closed_on;
  uncontrollable u_closed_off;
  controllable c_open;
  controllable c_close;
  controllable c_stop;
  alg bool fault = FTC.D.bridge_f;
  automaton button_open:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_stop:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton button_close:
    uncontrollable u_pushed;
    uncontrollable u_released;
    location released:
      initial;
      edge u_pushed goto pushed;
    location pushed:
      edge u_released goto released;
  end
  automaton A:
    disc bool o = false;
    disc bool c = false;
    location rest:
      initial;
      edge c_open do o := true, c := false goto opening;
      edge c_close do o := false, c := true goto closing;
      edge u_closed_off when fault;
    location opening:
      edge c_stop do o := false, c := false goto rest;
      edge u_open_on, u_closed_off;
    location closing:
      edge c_stop do o := false, c := false goto rest;
      edge u_open_off, u_closed_on;
  end
  automaton position:
    disc bool o = false;
    disc bool c = true;
    location closed:
      initial;
      edge u_closed_off do o := false, c := false goto between;
    location between:
      edge u_open_on do o := true, c := false goto up;
      edge u_closed_on do o := false, c := true goto closed;
    location up:
      edge u_open_off do o := false, c := false goto between;
  end
end
group FTC:
  automaton D:
    uncontrollable f1;
    uncontrollable f2;
    uncontrollable f3;
    uncontrollable f4;
    uncontrollable f5;
    uncontrollable f6;
    uncontrollable f7;
    uncontrollable f8;
    uncontrollable f9;
    uncontrollable f10;
    uncontrollable f11;
    uncontrollable f12;
    uncontrollable f13;
    uncontrollable f14;
    uncontrollable f15;
    uncontrollable f16;
    uncontrollable f17;
    uncontrollable f18;
    uncontrollable f19;
    uncontrollable f20;
    uncontrollable f25;
    uncontrollable r15;
    uncontrollable r16;
    uncontrollable r17;
    uncontrollable r18;
    uncontrollable r19;
    uncontrollable r20;
    disc bool ps1_f = false;
    disc bool ps2_f = false;
    disc bool ps3_f = false;
    disc bool ps4_f = false;
    disc bool ps5_f = false;
    disc bool ps6_f = false;
    disc bool s1_f = false;
    disc bool s2_f = false;
    disc bool s3_f = false;
    disc bool s4_f = false;
    disc bool s5_f = false;
    disc bool s6_f = false;
    disc bool s7_f = false;
    disc bool s8_f = false;
    disc bool bar1_f = false;
    disc bool bar4_f = false;
    disc bool bar3_f = false;
    disc bool bar2_f = false;
    disc bool bar5_f = false;
    disc bool bar6_f = false;
    disc bool bridge_f = true;
    svgin id "ps1" event f1 file "../e_svg_visualization.svg";
    svgin id "ps2" event f2 file "../e_svg_visualization.svg";
    svgin id "ps3" event f3 file "../e_svg_visualization.svg";
    svgin id "ps4" event f4 file "../e_svg_visualization.svg";
    svgin id "ps5" event f5 file "../e_svg_visualization.svg";
    svgin id "ps6" event f6 file "../e_svg_visualization.svg";
    svgin id "fs1" event f7 file "../e_svg_visualization.svg";
    svgin id "fs2" event f8 file "../e_svg_visualization.svg";
    svgin id "fs3" event f9 file "../e_svg_visualization.svg";
    svgin id "fs4" event f10 file "../e_svg_visualization.svg";
    svgin id "fs5" event f11 file "../e_svg_visualization.svg";
    svgin id "fs6" event f12 file "../e_svg_visualization.svg";
    svgin id "fs7" event f13 file "../e_svg_visualization.svg";
    svgin id "fs8" event f14 file "../e_svg_visualization.svg";
    svgin id "sc1" event if not bar1_f: f15 else r15 end file "../e_svg_visualization.svg";
    svgin id "sc5" event if not bar5_f: f19 else r19 end file "../e_svg_visualization.svg";
    svgin id "sc3" event if not bar3_f: f17 else r17 end file "../e_svg_visualization.svg";
    svgin id "sc2" event if not bar2_f: f18 else r18 end file "../e_svg_visualization.svg";
    svgin id "sc4" event if not bar4_f: f16 else r16 end file "../e_svg_visualization.svg";
    svgin id "sc6" event if not bar6_f: f20 else r20 end file "../e_svg_visualization.svg";
    svgin id "bridgedeck_bike" event f25 file "../e_svg_visualization.svg";
    location a:
      initial;
      edge f1 do ps1_f := true;
      edge f2 do ps2_f := true;
      edge f3 do ps3_f := true;
      edge f4 do ps4_f := true;
      edge f5 do ps5_f := true;
      edge f6 do ps6_f := true;
      edge f7 do s1_f := true;
      edge f8 do s2_f := true;
      edge f9 do s3_f := true;
      edge f10 do s4_f := true;
      edge f11 do s5_f := true;
      edge f12 do s6_f := true;
      edge f13 do s7_f := true;
      edge f14 do s8_f := true;
      edge f15 do bar1_f := true;
      edge r15 do bar1_f := false;
      edge f16 do bar4_f := true;
      edge r16 do bar4_f := false;
      edge f17 do bar3_f := true;
      edge r17 do bar3_f := false;
      edge f18 do bar2_f := true;
      edge r18 do bar2_f := false;
      edge f19 do bar5_f := true;
      edge r19 do bar5_f := false;
      edge f20 do bar6_f := true;
      edge r20 do bar6_f := false;
      edge f25 do bridge_f := true;
  end
end
group sup:
  group safety_reqirements:
    group Requirement1:
      alg bool Fault1 = FTC.D.ps1_f or FTC.D.ps2_f or FTC.D.ps3_f;
      alg bool Fault2 = FTC.D.ps4_f or FTC.D.ps5_f or FTC.D.ps6_f;
      alg bool Fault3 = FTC.D.bridge_f;
      group Nominal:
        requirement invariant .LTS.stopsigns.stop1.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
        requirement invariant .LTS.stopsigns.stop2.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
        requirement invariant .LTS.stopsigns.stop3.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
        requirement invariant .LTS.stopsigns.stop4.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
        requirement invariant .LTS.stopsigns.stop5.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
        requirement invariant .LTS.stopsigns.stop6.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
        requirement invariant .LTS.stopsigns.stop7.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
        requirement invariant .LTS.stopsigns.stop8.c_on needs not Fault3 => (not Fault1 => LTS.presigns.C_on) and (not Fault2 => LTS.presigns.K_on);
      end
      group PostFault1or2:
        requirement invariant .LTS.stopsigns.stop1.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
        requirement invariant .LTS.stopsigns.stop2.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
        requirement invariant .LTS.stopsigns.stop3.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
        requirement invariant .LTS.stopsigns.stop4.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
        requirement invariant .LTS.stopsigns.stop5.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
        requirement invariant .LTS.stopsigns.stop6.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
        requirement invariant .LTS.stopsigns.stop7.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
        requirement invariant .LTS.stopsigns.stop8.c_on needs not Fault3 => (Fault1 => LTS.presigns.C_onF) and (Fault2 => LTS.presigns.K_onF);
      end
      group PostFault3:
        requirement invariant .LTS.stopsigns.stop1.c_on needs Fault3 => true;
        requirement invariant .LTS.stopsigns.stop2.c_on needs Fault3 => true;
        requirement invariant .LTS.stopsigns.stop3.c_on needs Fault3 => true;
        requirement invariant .LTS.stopsigns.stop4.c_on needs Fault3 => true;
        requirement invariant .LTS.stopsigns.stop5.c_on needs Fault3 => true;
        requirement invariant .LTS.stopsigns.stop6.c_on needs Fault3 => true;
        requirement invariant .LTS.stopsigns.stop7.c_on needs Fault3 => true;
        requirement invariant .LTS.stopsigns.stop8.c_on needs Fault3 => true;
      end
    end
    group Requirement2:
      alg bool Fault1 = FTC.D.s1_f or FTC.D.s2_f;
      alg bool Fault2 = FTC.D.s3_f or FTC.D.s4_f;
      alg bool Fault3 = FTC.D.s5_f or FTC.D.s6_f;
      alg bool Fault4 = FTC.D.s7_f or FTC.D.s8_f;
      group Nominal:
        requirement invariant .barriers.barrier3.c_close needs (not Fault1 => LTS.stopsigns.C_on) and (not Fault2 => LTS.stopsigns.K_on) and (not Fault3 => LTS.stopsigns.SC_on) and (not Fault4 => LTS.stopsigns.SK_on);
        requirement invariant .barriers.barrier2.c_close needs (not Fault1 => LTS.stopsigns.C_on) and (not Fault2 => LTS.stopsigns.K_on) and (not Fault3 => LTS.stopsigns.SC_on) and (not Fault4 => LTS.stopsigns.SK_on);
        requirement invariant .barriers.barrier5.c_close needs (not Fault1 => LTS.stopsigns.C_on) and (not Fault2 => LTS.stopsigns.K_on) and (not Fault3 => LTS.stopsigns.SC_on) and (not Fault4 => LTS.stopsigns.SK_on);
        requirement invariant .barriers.barrier6.c_close needs (not Fault1 => LTS.stopsigns.C_on) and (not Fault2 => LTS.stopsigns.K_on) and (not Fault3 => LTS.stopsigns.SC_on) and (not Fault4 => LTS.stopsigns.SK_on);
      end
      group PostFault:
        requirement invariant .barriers.barrier2.c_close needs (Fault1 => LTS.stopsigns.C_onF) and (Fault2 => LTS.stopsigns.K_onF) and (Fault3 => LTS.stopsigns.SC_onF) and (Fault4 => LTS.stopsigns.SK_onF);
        requirement invariant .barriers.barrier3.c_close needs (Fault1 => LTS.stopsigns.C_onF) and (Fault2 => LTS.stopsigns.K_onF) and (Fault3 => LTS.stopsigns.SC_onF) and (Fault4 => LTS.stopsigns.SK_onF);
        requirement invariant .barriers.barrier5.c_close needs (Fault1 => LTS.stopsigns.C_onF) and (Fault2 => LTS.stopsigns.K_onF) and (Fault3 => LTS.stopsigns.SC_onF) and (Fault4 => LTS.stopsigns.SK_onF);
        requirement invariant .barriers.barrier6.c_close needs (Fault1 => LTS.stopsigns.C_onF) and (Fault2 => LTS.stopsigns.K_onF) and (Fault3 => LTS.stopsigns.SC_onF) and (Fault4 => LTS.stopsigns.SK_onF);
      end
    end
    group Requirement3:
      group Nominal:
        requirement invariant .barriers.barrier1.c_close needs barriers.entering_closed;
        requirement invariant .barriers.barrier4.c_close needs barriers.entering_closed;
      end
    end
    group Requirement4:
      group Nominal:
        requirement invariant .bridgedeck.c_open needs barriers.entering_closed and barriers.leaving_closed and barriers.slow_closed;
      end
    end
    group Requirement5:
      group Nominal:
        requirement invariant .shipping_signs.upstream.N.c_green needs bridgedeck.bridgedeck_up;
        requirement invariant .shipping_signs.upstream.S.c_green needs bridgedeck.bridgedeck_up;
        requirement invariant .shipping_signs.downstream.N.c_green needs bridgedeck.bridgedeck_up;
        requirement invariant .shipping_signs.downstream.S.c_green needs bridgedeck.bridgedeck_up;
      end
    end
    group Requirement6:
      group Nominal:
        requirement invariant .bridgedeck.c_close needs shipping_signs.RedOrRedRed;
      end
    end
    group Requirement7:
      group Nominal:
        requirement invariant .barriers.barrier1.c_open needs bridgedeck.bridgedeck_closed;
        requirement invariant .barriers.barrier2.c_open needs bridgedeck.bridgedeck_closed;
        requirement invariant .barriers.barrier3.c_open needs bridgedeck.bridgedeck_closed;
        requirement invariant .barriers.barrier4.c_open needs bridgedeck.bridgedeck_closed;
        requirement invariant .barriers.barrier5.c_open needs bridgedeck.bridgedeck_closed;
        requirement invariant .barriers.barrier6.c_open needs bridgedeck.bridgedeck_closed;
      end
    end
    group Requirement8:
      alg bool Fault1 = FTC.D.bar1_f;
      alg bool Fault2 = FTC.D.bar4_f;
      group Nominal:
        requirement invariant .barriers.barrier2.c_open needs (not Fault1 => barriers.barrier1.open) and (not Fault2 => barriers.barrier4.open);
        requirement invariant .barriers.barrier3.c_open needs (not Fault1 => barriers.barrier1.open) and (not Fault2 => barriers.barrier4.open);
      end
      group PostFault:
        requirement invariant .barriers.barrier2.c_open needs (Fault1 => false) and (Fault2 => true);
        requirement invariant .barriers.barrier3.c_open needs (Fault1 => true) and (Fault2 => false);
      end
    end
    group Requirement9:
      alg bool Fault1 = FTC.D.bar1_f or FTC.D.bar2_f;
      alg bool Fault2 = FTC.D.bar3_f or FTC.D.bar4_f;
      alg bool Fault3 = FTC.D.bar5_f or FTC.D.bar6_f;
      group Nominal:
        requirement invariant .LTS.stopsigns.stop1.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
        requirement invariant .LTS.stopsigns.stop2.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
        requirement invariant .LTS.stopsigns.stop3.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
        requirement invariant .LTS.stopsigns.stop4.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
        requirement invariant .LTS.stopsigns.stop5.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
        requirement invariant .LTS.stopsigns.stop6.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
        requirement invariant .LTS.stopsigns.stop7.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
        requirement invariant .LTS.stopsigns.stop8.c_off needs (not Fault1 => barriers.KtoC_open) and (not Fault2 => barriers.CtoK_open) and (not Fault3 => barriers.slow_open);
      end
      group PostFault:
        requirement invariant .LTS.stopsigns.stop3.c_off needs (Fault1 => false) and (Fault2 => true) and (Fault3 => true);
        requirement invariant .LTS.stopsigns.stop4.c_off needs (Fault1 => false) and (Fault2 => true) and (Fault3 => true);
        requirement invariant .LTS.stopsigns.stop1.c_off needs (Fault1 => true) and (Fault2 => false) and (Fault3 => true);
        requirement invariant .LTS.stopsigns.stop2.c_off needs (Fault1 => true) and (Fault2 => false) and (Fault3 => true);
        requirement invariant .LTS.stopsigns.stop5.c_off needs (Fault1 => true) and (Fault2 => true) and (Fault3 => false);
        requirement invariant .LTS.stopsigns.stop6.c_off needs (Fault1 => true) and (Fault2 => true) and (Fault3 => false);
        requirement invariant .LTS.stopsigns.stop7.c_off needs (Fault1 => true) and (Fault2 => true) and (Fault3 => false);
        requirement invariant .LTS.stopsigns.stop8.c_off needs (Fault1 => true) and (Fault2 => true) and (Fault3 => false);
      end
    end
    group Requirement10:
      alg bool Fault1 = FTC.D.bar1_f or FTC.D.bar2_f;
      alg bool Fault2 = FTC.D.bar3_f or FTC.D.bar4_f;
      alg bool Fault3 = FTC.D.bar5_f or FTC.D.bar6_f;
      group Nominal:
        requirement invariant .LTS.presigns.ps1.c_off needs (not Fault1 => LTS.stopsigns.K_off) and (not Fault2 => LTS.stopsigns.C_off) and (not Fault3 => LTS.stopsigns.slow_off);
        requirement invariant .LTS.presigns.ps2.c_off needs (not Fault1 => LTS.stopsigns.K_off) and (not Fault2 => LTS.stopsigns.C_off) and (not Fault3 => LTS.stopsigns.slow_off);
        requirement invariant .LTS.presigns.ps3.c_off needs (not Fault1 => LTS.stopsigns.K_off) and (not Fault2 => LTS.stopsigns.C_off) and (not Fault3 => LTS.stopsigns.slow_off);
        requirement invariant .LTS.presigns.ps4.c_off needs (not Fault1 => LTS.stopsigns.K_off) and (not Fault2 => LTS.stopsigns.C_off) and (not Fault3 => LTS.stopsigns.slow_off);
        requirement invariant .LTS.presigns.ps5.c_off needs (not Fault1 => LTS.stopsigns.K_off) and (not Fault2 => LTS.stopsigns.C_off) and (not Fault3 => LTS.stopsigns.slow_off);
        requirement invariant .LTS.presigns.ps6.c_off needs (not Fault1 => LTS.stopsigns.K_off) and (not Fault2 => LTS.stopsigns.C_off) and (not Fault3 => LTS.stopsigns.slow_off);
      end
      group PostFault:
        requirement invariant .LTS.presigns.ps1.c_off needs (Fault1 => true) and (Fault2 => false) and (Fault3 => true);
        requirement invariant .LTS.presigns.ps2.c_off needs (Fault1 => true) and (Fault2 => false) and (Fault3 => true);
        requirement invariant .LTS.presigns.ps3.c_off needs (Fault1 => true) and (Fault2 => false) and (Fault3 => true);
        requirement invariant .LTS.presigns.ps4.c_off needs (Fault1 => false) and (Fault2 => true) and (Fault3 => true);
        requirement invariant .LTS.presigns.ps5.c_off needs (Fault1 => false) and (Fault2 => true) and (Fault3 => true);
        requirement invariant .LTS.presigns.ps6.c_off needs (Fault1 => false) and (Fault2 => true) and (Fault3 => true);
      end
    end
  end
  group function_requirements:
    group LTS_Functional:
      group stopsigns:
        group stopsign1:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop1.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop1.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop1.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop1.c_off needs f_bridge => true;
          end
        end
        group stopsign2:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop2.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop2.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop2.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop2.c_off needs f_bridge => true;
          end
        end
        group stopsign3:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop3.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop3.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop3.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop3.c_off needs f_bridge => true;
          end
        end
        group stopsign4:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop4.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop4.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop4.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop4.c_off needs f_bridge => true;
          end
        end
        group stopsign5:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop5.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop5.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop5.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop5.c_off needs f_bridge => true;
          end
        end
        group stopsign6:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop6.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop6.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop6.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop6.c_off needs f_bridge => true;
          end
        end
        group stopsign7:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop7.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop7.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop7.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop7.c_off needs f_bridge => true;
          end
        end
        group stopsign8:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.stopsigns.stop8.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.stopsigns.stop8.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.stopsigns.stop8.c_on needs f_bridge => true;
            requirement invariant .LTS.stopsigns.stop8.c_off needs f_bridge => true;
          end
        end
      end
      group presigns:
        group presignps1:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.presigns.ps1.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.presigns.ps1.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.presigns.ps1.c_on needs f_bridge => true;
            requirement invariant .LTS.presigns.ps1.c_off needs f_bridge => true;
          end
        end
        group presignps2:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.presigns.ps2.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.presigns.ps2.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.presigns.ps2.c_on needs f_bridge => true;
            requirement invariant .LTS.presigns.ps2.c_off needs f_bridge => true;
          end
        end
        group presignps3:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.presigns.ps3.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.presigns.ps3.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.presigns.ps3.c_on needs f_bridge => true;
            requirement invariant .LTS.presigns.ps3.c_off needs f_bridge => true;
          end
        end
        group presignps4:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.presigns.ps4.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.presigns.ps4.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.presigns.ps4.c_on needs f_bridge => true;
            requirement invariant .LTS.presigns.ps4.c_off needs f_bridge => true;
          end
        end
        group presignps5:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.presigns.ps5.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.presigns.ps5.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.presigns.ps5.c_on needs f_bridge => true;
            requirement invariant .LTS.presigns.ps5.c_off needs f_bridge => true;
          end
        end
        group presignps6:
          alg bool f_bridge = FTC.D.bridge_f;
          group Nominal:
            requirement invariant .LTS.presigns.ps6.c_on needs not f_bridge => LTS.button_on.pushed;
            requirement invariant .LTS.presigns.ps6.c_off needs not f_bridge => bridgedeck.command_close and not LTS.button_on.pushed;
          end
          group PostFault2:
            requirement invariant .LTS.presigns.ps6.c_on needs f_bridge => true;
            requirement invariant .LTS.presigns.ps6.c_off needs f_bridge => true;
          end
        end
      end
    end
    group Barriers_Functional:
      group barrier1:
        alg bool command_close = barriers.command_close_leaving;
        alg bool command_open = barriers.command_open_leaving;
        alg bool command_stop = barriers.command_stop_leaving;
        alg bool barrier_S_closed = barriers.barrier1.S.closed;
        alg bool barrier_S_open = barriers.barrier1.S.open;
        alg bool barrier_A_closing = barriers.barrier1.A.closing;
        alg bool barrier_A_opening = barriers.barrier1.A.opening;
        alg bool f_sc = FTC.D.bar1_f;
        group Nominal:
          requirement invariant .barriers.barrier1.c_close needs not f_sc => command_close and not barrier_S_closed;
          requirement invariant .barriers.barrier1.c_stop needs not f_sc => command_stop or barrier_S_closed and barrier_A_closing or barrier_S_open and barrier_A_opening;
          requirement invariant .barriers.barrier1.c_open needs not f_sc => (command_open or bridgedeck.command_close) and not command_close and not command_stop and not barrier_S_open;
        end
        group PostFault:
          requirement invariant .barriers.barrier1.c_stop needs f_sc => true;
          requirement invariant .barriers.barrier1.c_close needs f_sc => false;
          requirement invariant .barriers.barrier1.c_open needs f_sc => false;
        end
      end
      group barrier2:
        alg bool command_close = barriers.command_close_entering;
        alg bool command_open = barriers.command_open_entering;
        alg bool command_stop = barriers.command_stop_entering;
        alg bool barrier_S_closed = barriers.barrier2.S.closed;
        alg bool barrier_S_open = barriers.barrier2.S.open;
        alg bool barrier_A_closing = barriers.barrier2.A.closing;
        alg bool barrier_A_opening = barriers.barrier2.A.opening;
        alg bool f_sc = FTC.D.bar2_f;
        group Nominal:
          requirement invariant .barriers.barrier2.c_close needs not f_sc => command_close and not barrier_S_closed;
          requirement invariant .barriers.barrier2.c_stop needs not f_sc => command_stop or barrier_S_closed and barrier_A_closing or barrier_S_open and barrier_A_opening;
          requirement invariant .barriers.barrier2.c_open needs not f_sc => (command_open or bridgedeck.command_close) and not command_close and not command_stop and not barrier_S_open;
        end
        group PostFault:
          requirement invariant .barriers.barrier2.c_stop needs f_sc => true;
          requirement invariant .barriers.barrier2.c_close needs f_sc => false;
          requirement invariant .barriers.barrier2.c_open needs f_sc => false;
        end
      end
      group barrier3:
        alg bool command_close = barriers.command_close_entering;
        alg bool command_open = barriers.command_open_entering;
        alg bool command_stop = barriers.command_stop_entering;
        alg bool barrier_S_closed = barriers.barrier3.S.closed;
        alg bool barrier_S_open = barriers.barrier3.S.open;
        alg bool barrier_A_closing = barriers.barrier3.A.closing;
        alg bool barrier_A_opening = barriers.barrier3.A.opening;
        alg bool f_sc = FTC.D.bar3_f;
        group Nominal:
          requirement invariant .barriers.barrier3.c_close needs not f_sc => command_close and not barrier_S_closed;
          requirement invariant .barriers.barrier3.c_stop needs not f_sc => command_stop or barrier_S_closed and barrier_A_closing or barrier_S_open and barrier_A_opening;
          requirement invariant .barriers.barrier3.c_open needs not f_sc => (command_open or bridgedeck.command_close) and not command_close and not command_stop and not barrier_S_open;
        end
        group PostFault:
          requirement invariant .barriers.barrier3.c_stop needs f_sc => true;
          requirement invariant .barriers.barrier3.c_close needs f_sc => false;
          requirement invariant .barriers.barrier3.c_open needs f_sc => false;
        end
      end
      group barrier4:
        alg bool command_close = barriers.command_close_leaving;
        alg bool command_open = barriers.command_open_leaving;
        alg bool command_stop = barriers.command_stop_leaving;
        alg bool barrier_S_closed = barriers.barrier4.S.closed;
        alg bool barrier_S_open = barriers.barrier4.S.open;
        alg bool barrier_A_closing = barriers.barrier4.A.closing;
        alg bool barrier_A_opening = barriers.barrier4.A.opening;
        alg bool f_sc = FTC.D.bar4_f;
        group Nominal:
          requirement invariant .barriers.barrier4.c_close needs not f_sc => command_close and not barrier_S_closed;
          requirement invariant .barriers.barrier4.c_stop needs not f_sc => command_stop or barrier_S_closed and barrier_A_closing or barrier_S_open and barrier_A_opening;
          requirement invariant .barriers.barrier4.c_open needs not f_sc => (command_open or bridgedeck.command_close) and not command_close and not command_stop and not barrier_S_open;
        end
        group PostFault:
          requirement invariant .barriers.barrier4.c_stop needs f_sc => true;
          requirement invariant .barriers.barrier4.c_close needs f_sc => false;
          requirement invariant .barriers.barrier4.c_open needs f_sc => false;
        end
      end
      group barrier5:
        alg bool command_close = barriers.command_close_slow;
        alg bool command_open = barriers.command_open_slow;
        alg bool command_stop = barriers.command_stop_slow;
        alg bool barrier_S_closed = barriers.barrier5.S.closed;
        alg bool barrier_S_open = barriers.barrier5.S.open;
        alg bool barrier_A_closing = barriers.barrier5.A.closing;
        alg bool barrier_A_opening = barriers.barrier5.A.opening;
        alg bool f_sc = FTC.D.bar5_f;
        group Nominal:
          requirement invariant .barriers.barrier5.c_close needs not f_sc => command_close and not barrier_S_closed;
          requirement invariant .barriers.barrier5.c_stop needs not f_sc => command_stop or barrier_S_closed and barrier_A_closing or barrier_S_open and barrier_A_opening;
          requirement invariant .barriers.barrier5.c_open needs not f_sc => (command_open or bridgedeck.command_close) and not command_close and not command_stop and not barrier_S_open;
        end
        group PostFault:
          requirement invariant .barriers.barrier5.c_stop needs f_sc => true;
          requirement invariant .barriers.barrier5.c_close needs f_sc => false;
          requirement invariant .barriers.barrier5.c_open needs f_sc => false;
        end
      end
      group barrier6:
        alg bool command_close = barriers.command_close_slow;
        alg bool command_open = barriers.command_open_slow;
        alg bool command_stop = barriers.command_stop_slow;
        alg bool barrier_S_closed = barriers.barrier6.S.closed;
        alg bool barrier_S_open = barriers.barrier6.S.open;
        alg bool barrier_A_closing = barriers.barrier6.A.closing;
        alg bool barrier_A_opening = barriers.barrier6.A.opening;
        alg bool f_sc = FTC.D.bar6_f;
        group Nominal:
          requirement invariant .barriers.barrier6.c_close needs not f_sc => command_close and not barrier_S_closed;
          requirement invariant .barriers.barrier6.c_stop needs not f_sc => command_stop or barrier_S_closed and barrier_A_closing or barrier_S_open and barrier_A_opening;
          requirement invariant .barriers.barrier6.c_open needs not f_sc => (command_open or bridgedeck.command_close) and not command_close and not command_stop and not barrier_S_open;
        end
        group PostFault:
          requirement invariant .barriers.barrier6.c_stop needs f_sc => true;
          requirement invariant .barriers.barrier6.c_close needs f_sc => false;
          requirement invariant .barriers.barrier6.c_open needs f_sc => false;
        end
      end
    end
    group Shipping_sign_Functional:
      group sign1:
        alg bool command_rd = shipping_signs.upstream.command_rd;
        alg bool command_gn = shipping_signs.upstream.command_gn;
        alg bool command_rg = shipping_signs.upstream.command_rg;
        alg bool command_sp = shipping_signs.upstream.command_sp;
        group Nominal:
          requirement invariant .shipping_signs.upstream.N.c_red needs command_rd or bridgedeck.button_stop.pushed and bridgedeck.S.between;
          requirement invariant .shipping_signs.upstream.N.c_redgreen needs command_rg;
          requirement invariant .shipping_signs.upstream.N.c_redred needs command_sp;
          requirement invariant .shipping_signs.upstream.N.c_green needs command_gn;
        end
      end
      group sign2:
        alg bool command_rd = shipping_signs.upstream.command_rd;
        alg bool command_gn = shipping_signs.upstream.command_gn;
        alg bool command_rg = shipping_signs.upstream.command_rg;
        alg bool command_sp = shipping_signs.upstream.command_sp;
        group Nominal:
          requirement invariant .shipping_signs.upstream.S.c_red needs command_rd or bridgedeck.button_stop.pushed and bridgedeck.S.between;
          requirement invariant .shipping_signs.upstream.S.c_redgreen needs command_rg;
          requirement invariant .shipping_signs.upstream.S.c_redred needs command_sp;
          requirement invariant .shipping_signs.upstream.S.c_green needs command_gn;
        end
      end
      group sign3:
        alg bool command_rd = shipping_signs.downstream.command_rd;
        alg bool command_gn = shipping_signs.downstream.command_gn;
        alg bool command_rg = shipping_signs.downstream.command_rg;
        alg bool command_sp = shipping_signs.downstream.command_sp;
        group Nominal:
          requirement invariant .shipping_signs.downstream.N.c_red needs command_rd or bridgedeck.button_stop.pushed and bridgedeck.S.between;
          requirement invariant .shipping_signs.downstream.N.c_redgreen needs command_rg;
          requirement invariant .shipping_signs.downstream.N.c_redred needs command_sp;
          requirement invariant .shipping_signs.downstream.N.c_green needs command_gn;
        end
      end
      group sign4:
        alg bool command_rd = shipping_signs.downstream.command_rd;
        alg bool command_gn = shipping_signs.downstream.command_gn;
        alg bool command_rg = shipping_signs.downstream.command_rg;
        alg bool command_sp = shipping_signs.downstream.command_sp;
        group Nominal:
          requirement invariant .shipping_signs.downstream.S.c_red needs command_rd or bridgedeck.button_stop.pushed and bridgedeck.S.between;
          requirement invariant .shipping_signs.downstream.S.c_redgreen needs command_rg;
          requirement invariant .shipping_signs.downstream.S.c_redred needs command_sp;
          requirement invariant .shipping_signs.downstream.S.c_green needs command_gn;
        end
      end
    end
    group Bridgedeck_Functional:
      group nominal:
        requirement invariant .bridgedeck.c_open needs bridgedeck.command_open and not bridgedeck.S.up;
        requirement invariant .bridgedeck.c_close needs bridgedeck.command_close and not bridgedeck.S.closed;
        requirement invariant .bridgedeck.c_stop needs bridgedeck.command_stop or bridgedeck.S.up and bridgedeck.A.opening or bridgedeck.S.closed and bridgedeck.A.closing;
      end
    end
  end
  group LTS:
    plant automaton button_on:
      location released:
        initial;
        marked;
        edge .LTS.button_on.u_pushed goto pushed;
      location pushed:
        edge .LTS.button_on.u_released goto released;
    end
    group presigns:
      alg bool C_on = ps1.on and ps2.on and ps3.on;
      alg bool K_on = ps4.on and ps5.on and ps6.on;
      alg bool C_onF = ps2.on and ps3.on or ps1.on and ps3.on or ps1.on and ps2.on;
      alg bool K_onF = ps5.on and ps6.on or ps4.on and ps6.on or ps4.on and ps5.on;
      group ps1:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.ps1_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps1.c_on goto on;
          location on:
            edge .LTS.presigns.ps1.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps1.u_on goto on;
          location on:
            edge .LTS.presigns.ps1.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps1.u_on when not f => A.on;
            edge .LTS.presigns.ps1.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps1.u_on when f => false;
            edge .LTS.presigns.ps1.u_off when f => true;
        end
      end
      group ps2:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.ps2_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps2.c_on goto on;
          location on:
            edge .LTS.presigns.ps2.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps2.u_on goto on;
          location on:
            edge .LTS.presigns.ps2.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps2.u_on when not f => A.on;
            edge .LTS.presigns.ps2.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps2.u_on when f => false;
            edge .LTS.presigns.ps2.u_off when f => true;
        end
      end
      group ps3:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.ps3_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps3.c_on goto on;
          location on:
            edge .LTS.presigns.ps3.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps3.u_on goto on;
          location on:
            edge .LTS.presigns.ps3.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps3.u_on when not f => A.on;
            edge .LTS.presigns.ps3.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps3.u_on when f => false;
            edge .LTS.presigns.ps3.u_off when f => true;
        end
      end
      group ps4:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.ps4_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps4.c_on goto on;
          location on:
            edge .LTS.presigns.ps4.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps4.u_on goto on;
          location on:
            edge .LTS.presigns.ps4.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps4.u_on when not f => A.on;
            edge .LTS.presigns.ps4.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps4.u_on when f => false;
            edge .LTS.presigns.ps4.u_off when f => true;
        end
      end
      group ps5:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.ps5_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps5.c_on goto on;
          location on:
            edge .LTS.presigns.ps5.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps5.u_on goto on;
          location on:
            edge .LTS.presigns.ps5.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps5.u_on when not f => A.on;
            edge .LTS.presigns.ps5.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps5.u_on when f => false;
            edge .LTS.presigns.ps5.u_off when f => true;
        end
      end
      group ps6:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.ps6_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps6.c_on goto on;
          location on:
            edge .LTS.presigns.ps6.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.presigns.ps6.u_on goto on;
          location on:
            edge .LTS.presigns.ps6.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps6.u_on when not f => A.on;
            edge .LTS.presigns.ps6.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.presigns.ps6.u_on when f => false;
            edge .LTS.presigns.ps6.u_off when f => true;
        end
      end
    end
    group stopsigns:
      alg bool C_on = stop1.on and stop2.on;
      alg bool K_on = stop3.on and stop4.on;
      alg bool SC_on = stop5.on and stop6.on;
      alg bool SK_on = stop7.on and stop8.on;
      alg bool C_off = stop1.off and stop2.off;
      alg bool K_off = stop3.off and stop4.off;
      alg bool SC_off = stop5.off and stop6.off;
      alg bool SK_off = stop7.off and stop8.off;
      alg bool slow_off = SC_off and SK_off;
      alg bool C_onF = stop1.on or stop2.on;
      alg bool K_onF = stop3.on or stop4.on;
      alg bool SC_onF = stop5.on or stop6.on;
      alg bool SK_onF = stop7.on or stop8.on;
      group stop1:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s1_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop1.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop1.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop1.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop1.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop1.u_on when not f => A.on;
            edge .LTS.stopsigns.stop1.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop1.u_on when f => false;
            edge .LTS.stopsigns.stop1.u_off when f => true;
        end
      end
      group stop2:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s2_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop2.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop2.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop2.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop2.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop2.u_on when not f => A.on;
            edge .LTS.stopsigns.stop2.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop2.u_on when f => false;
            edge .LTS.stopsigns.stop2.u_off when f => true;
        end
      end
      group stop3:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s3_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop3.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop3.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop3.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop3.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop3.u_on when not f => A.on;
            edge .LTS.stopsigns.stop3.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop3.u_on when f => false;
            edge .LTS.stopsigns.stop3.u_off when f => true;
        end
      end
      group stop4:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s4_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop4.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop4.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop4.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop4.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop4.u_on when not f => A.on;
            edge .LTS.stopsigns.stop4.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop4.u_on when f => false;
            edge .LTS.stopsigns.stop4.u_off when f => true;
        end
      end
      group stop5:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s5_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop5.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop5.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop5.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop5.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop5.u_on when not f => A.on;
            edge .LTS.stopsigns.stop5.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop5.u_on when f => false;
            edge .LTS.stopsigns.stop5.u_off when f => true;
        end
      end
      group stop6:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s6_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop6.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop6.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop6.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop6.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop6.u_on when not f => A.on;
            edge .LTS.stopsigns.stop6.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop6.u_on when f => false;
            edge .LTS.stopsigns.stop6.u_off when f => true;
        end
      end
      group stop7:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s7_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop7.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop7.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop7.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop7.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop7.u_on when not f => A.on;
            edge .LTS.stopsigns.stop7.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop7.u_on when f => false;
            edge .LTS.stopsigns.stop7.u_off when f => true;
        end
      end
      group stop8:
        alg bool on = A.on and S.on;
        alg bool off = A.off and S.off;
        alg bool f = FTC.D.s8_f;
        plant automaton A:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop8.c_on goto on;
          location on:
            edge .LTS.stopsigns.stop8.c_off goto off;
        end
        plant automaton S:
          location off:
            initial;
            marked;
            edge .LTS.stopsigns.stop8.u_on goto on;
          location on:
            edge .LTS.stopsigns.stop8.u_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop8.u_on when not f => A.on;
            edge .LTS.stopsigns.stop8.u_off when not f => A.off;
        end
        plant automaton PostFaultDynamics:
          location:
            initial;
            marked;
            edge .LTS.stopsigns.stop8.u_on when f => false;
            edge .LTS.stopsigns.stop8.u_off when f => true;
        end
      end
    end
  end
  group barriers:
    alg bool entering_closed = barrier2.closed and barrier3.closed;
    alg bool leaving_closed = barrier1.closed and barrier4.closed;
    alg bool slow_closed = barrier5.closed and barrier6.closed;
    alg bool leaving_open = barrier1.open and barrier4.open;
    alg bool CtoK_open = barrier3.open and barrier4.open;
    alg bool KtoC_open = barrier1.open and barrier2.open;
    alg bool slow_open = barrier5.open and barrier6.open;
    alg bool all_closed = entering_closed and leaving_closed and slow_closed;
    alg bool all_open = CtoK_open and KtoC_open and slow_open;
    alg bool command_stop_entering = button_stop_entering.pushed;
    alg bool command_close_entering = button_close_entering.pushed and not command_stop_entering;
    alg bool command_open_entering = button_open_entering.pushed and not command_stop_entering and not command_close_entering;
    alg bool command_stop_leaving = button_stop_leaving.pushed;
    alg bool command_close_leaving = button_close_leaving.pushed and not command_stop_leaving;
    alg bool command_open_leaving = button_open_leaving.pushed and not command_stop_leaving and not command_close_leaving;
    alg bool command_stop_slow = button_stop_slow.pushed;
    alg bool command_close_slow = button_close_slow.pushed and not command_stop_slow;
    alg bool command_open_slow = button_open_slow.pushed and not command_stop_slow and not command_close_slow;
    group barrier1:
      alg bool open = A.rest and S.open;
      alg bool closed = A.rest and S.closed;
      alg bool f_sc = FTC.D.bar1_f;
      plant automaton A:
        location rest:
          initial;
          marked;
          edge .barriers.barrier1.c_open goto opening;
          edge .barriers.barrier1.c_close goto closing;
        location opening:
          edge .barriers.barrier1.c_stop goto rest;
        location closing:
          edge .barriers.barrier1.c_stop goto rest;
      end
      plant automaton S:
        location open:
          initial;
          marked;
          edge .barriers.barrier1.u_open_off goto between;
        location between:
          edge .barriers.barrier1.u_open_on goto open;
          edge .barriers.barrier1.u_closed_on goto closed;
        location closed:
          edge .barriers.barrier1.u_closed_off goto between;
      end
      plant automaton NominalDynamics:
        location:
          initial;
          marked;
          edge .barriers.barrier1.u_open_off when not f_sc => A.closing;
          edge .barriers.barrier1.u_open_on when not f_sc => A.opening;
          edge .barriers.barrier1.u_closed_off when not f_sc => A.opening;
          edge .barriers.barrier1.u_closed_on when not f_sc => A.closing;
      end
      plant automaton PostFaultDynamicsSC:
        location:
          initial;
          marked;
          edge .barriers.barrier1.u_open_off when f_sc => A.closing;
          edge .barriers.barrier1.u_open_on when f_sc => A.opening;
          edge .barriers.barrier1.u_closed_off when f_sc => false;
          edge .barriers.barrier1.u_closed_on when f_sc => A.closing;
      end
    end
    group barrier2:
      alg bool open = A.rest and S.open;
      alg bool closed = A.rest and S.closed;
      alg bool f_sc = FTC.D.bar2_f;
      plant automaton A:
        location rest:
          initial;
          marked;
          edge .barriers.barrier2.c_open goto opening;
          edge .barriers.barrier2.c_close goto closing;
        location opening:
          edge .barriers.barrier2.c_stop goto rest;
        location closing:
          edge .barriers.barrier2.c_stop goto rest;
      end
      plant automaton S:
        location open:
          initial;
          marked;
          edge .barriers.barrier2.u_open_off goto between;
        location between:
          edge .barriers.barrier2.u_open_on goto open;
          edge .barriers.barrier2.u_closed_on goto closed;
        location closed:
          edge .barriers.barrier2.u_closed_off goto between;
      end
      plant automaton NominalDynamics:
        location:
          initial;
          marked;
          edge .barriers.barrier2.u_open_off when not f_sc => A.closing;
          edge .barriers.barrier2.u_open_on when not f_sc => A.opening;
          edge .barriers.barrier2.u_closed_off when not f_sc => A.opening;
          edge .barriers.barrier2.u_closed_on when not f_sc => A.closing;
      end
      plant automaton PostFaultDynamicsSC:
        location:
          initial;
          marked;
          edge .barriers.barrier2.u_open_off when f_sc => A.closing;
          edge .barriers.barrier2.u_open_on when f_sc => A.opening;
          edge .barriers.barrier2.u_closed_off when f_sc => false;
          edge .barriers.barrier2.u_closed_on when f_sc => A.closing;
      end
    end
    group barrier3:
      alg bool open = A.rest and S.open;
      alg bool closed = A.rest and S.closed;
      alg bool f_sc = FTC.D.bar3_f;
      plant automaton A:
        location rest:
          initial;
          marked;
          edge .barriers.barrier3.c_open goto opening;
          edge .barriers.barrier3.c_close goto closing;
        location opening:
          edge .barriers.barrier3.c_stop goto rest;
        location closing:
          edge .barriers.barrier3.c_stop goto rest;
      end
      plant automaton S:
        location open:
          initial;
          marked;
          edge .barriers.barrier3.u_open_off goto between;
        location between:
          edge .barriers.barrier3.u_open_on goto open;
          edge .barriers.barrier3.u_closed_on goto closed;
        location closed:
          edge .barriers.barrier3.u_closed_off goto between;
      end
      plant automaton NominalDynamics:
        location:
          initial;
          marked;
          edge .barriers.barrier3.u_open_off when not f_sc => A.closing;
          edge .barriers.barrier3.u_open_on when not f_sc => A.opening;
          edge .barriers.barrier3.u_closed_off when not f_sc => A.opening;
          edge .barriers.barrier3.u_closed_on when not f_sc => A.closing;
      end
      plant automaton PostFaultDynamicsSC:
        location:
          initial;
          marked;
          edge .barriers.barrier3.u_open_off when f_sc => A.closing;
          edge .barriers.barrier3.u_open_on when f_sc => A.opening;
          edge .barriers.barrier3.u_closed_off when f_sc => false;
          edge .barriers.barrier3.u_closed_on when f_sc => A.closing;
      end
    end
    group barrier4:
      alg bool open = A.rest and S.open;
      alg bool closed = A.rest and S.closed;
      alg bool f_sc = FTC.D.bar4_f;
      plant automaton A:
        location rest:
          initial;
          marked;
          edge .barriers.barrier4.c_open goto opening;
          edge .barriers.barrier4.c_close goto closing;
        location opening:
          edge .barriers.barrier4.c_stop goto rest;
        location closing:
          edge .barriers.barrier4.c_stop goto rest;
      end
      plant automaton S:
        location open:
          initial;
          marked;
          edge .barriers.barrier4.u_open_off goto between;
        location between:
          edge .barriers.barrier4.u_open_on goto open;
          edge .barriers.barrier4.u_closed_on goto closed;
        location closed:
          edge .barriers.barrier4.u_closed_off goto between;
      end
      plant automaton NominalDynamics:
        location:
          initial;
          marked;
          edge .barriers.barrier4.u_open_off when not f_sc => A.closing;
          edge .barriers.barrier4.u_open_on when not f_sc => A.opening;
          edge .barriers.barrier4.u_closed_off when not f_sc => A.opening;
          edge .barriers.barrier4.u_closed_on when not f_sc => A.closing;
      end
      plant automaton PostFaultDynamicsSC:
        location:
          initial;
          marked;
          edge .barriers.barrier4.u_open_off when f_sc => A.closing;
          edge .barriers.barrier4.u_open_on when f_sc => A.opening;
          edge .barriers.barrier4.u_closed_off when f_sc => false;
          edge .barriers.barrier4.u_closed_on when f_sc => A.closing;
      end
    end
    group barrier5:
      alg bool open = A.rest and S.open;
      alg bool closed = A.rest and S.closed;
      alg bool f_sc = FTC.D.bar5_f;
      plant automaton A:
        location rest:
          initial;
          marked;
          edge .barriers.barrier5.c_open goto opening;
          edge .barriers.barrier5.c_close goto closing;
        location opening:
          edge .barriers.barrier5.c_stop goto rest;
        location closing:
          edge .barriers.barrier5.c_stop goto rest;
      end
      plant automaton S:
        location open:
          initial;
          marked;
          edge .barriers.barrier5.u_open_off goto between;
        location between:
          edge .barriers.barrier5.u_open_on goto open;
          edge .barriers.barrier5.u_closed_on goto closed;
        location closed:
          edge .barriers.barrier5.u_closed_off goto between;
      end
      plant automaton NominalDynamics:
        location:
          initial;
          marked;
          edge .barriers.barrier5.u_open_off when not f_sc => A.closing;
          edge .barriers.barrier5.u_open_on when not f_sc => A.opening;
          edge .barriers.barrier5.u_closed_off when not f_sc => A.opening;
          edge .barriers.barrier5.u_closed_on when not f_sc => A.closing;
      end
      plant automaton PostFaultDynamicsSC:
        location:
          initial;
          marked;
          edge .barriers.barrier5.u_open_off when f_sc => A.closing;
          edge .barriers.barrier5.u_open_on when f_sc => A.opening;
          edge .barriers.barrier5.u_closed_off when f_sc => false;
          edge .barriers.barrier5.u_closed_on when f_sc => A.closing;
      end
    end
    group barrier6:
      alg bool open = A.rest and S.open;
      alg bool closed = A.rest and S.closed;
      alg bool f_sc = FTC.D.bar6_f;
      plant automaton A:
        location rest:
          initial;
          marked;
          edge .barriers.barrier6.c_open goto opening;
          edge .barriers.barrier6.c_close goto closing;
        location opening:
          edge .barriers.barrier6.c_stop goto rest;
        location closing:
          edge .barriers.barrier6.c_stop goto rest;
      end
      plant automaton S:
        location open:
          initial;
          marked;
          edge .barriers.barrier6.u_open_off goto between;
        location between:
          edge .barriers.barrier6.u_open_on goto open;
          edge .barriers.barrier6.u_closed_on goto closed;
        location closed:
          edge .barriers.barrier6.u_closed_off goto between;
      end
      plant automaton NominalDynamics:
        location:
          initial;
          marked;
          edge .barriers.barrier6.u_open_off when not f_sc => A.closing;
          edge .barriers.barrier6.u_open_on when not f_sc => A.opening;
          edge .barriers.barrier6.u_closed_off when not f_sc => A.opening;
          edge .barriers.barrier6.u_closed_on when not f_sc => A.closing;
      end
      plant automaton PostFaultDynamicsSC:
        location:
          initial;
          marked;
          edge .barriers.barrier6.u_open_off when f_sc => A.closing;
          edge .barriers.barrier6.u_open_on when f_sc => A.opening;
          edge .barriers.barrier6.u_closed_off when f_sc => false;
          edge .barriers.barrier6.u_closed_on when f_sc => A.closing;
      end
    end
    plant automaton button_close_entering:
      location released:
        initial;
        marked;
        edge .barriers.button_close_entering.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_close_entering.u_released goto released;
    end
    plant automaton button_stop_entering:
      location released:
        initial;
        marked;
        edge .barriers.button_stop_entering.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_stop_entering.u_released goto released;
    end
    plant automaton button_open_entering:
      location released:
        initial;
        marked;
        edge .barriers.button_open_entering.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_open_entering.u_released goto released;
    end
    plant automaton button_close_leaving:
      location released:
        initial;
        marked;
        edge .barriers.button_close_leaving.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_close_leaving.u_released goto released;
    end
    plant automaton button_stop_leaving:
      location released:
        initial;
        marked;
        edge .barriers.button_stop_leaving.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_stop_leaving.u_released goto released;
    end
    plant automaton button_open_leaving:
      location released:
        initial;
        marked;
        edge .barriers.button_open_leaving.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_open_leaving.u_released goto released;
    end
    plant automaton button_close_slow:
      location released:
        initial;
        marked;
        edge .barriers.button_close_slow.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_close_slow.u_released goto released;
    end
    plant automaton button_stop_slow:
      location released:
        initial;
        marked;
        edge .barriers.button_stop_slow.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_stop_slow.u_released goto released;
    end
    plant automaton button_open_slow:
      location released:
        initial;
        marked;
        edge .barriers.button_open_slow.u_pushed goto pushed;
      location pushed:
        edge .barriers.button_open_slow.u_released goto released;
    end
  end
  group shipping_signs:
    alg bool RedOrRedRed = upstream.RedOrRedRed and downstream.RedOrRedRed;
    group upstream:
      alg bool RedOrRedRed = N.RedOrRedRed and S.RedOrRedRed;
      alg bool command_rd = button_red.pushed;
      alg bool command_rg = button_redgreen.pushed and not button_red.pushed;
      alg bool command_gn = button_green.pushed and not button_red.pushed and not button_redgreen.pushed;
      alg bool command_sp = button_redred.pushed and not button_red.pushed;
      plant automaton button_red:
        location released:
          initial;
          marked;
          edge .shipping_signs.upstream.button_red.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.upstream.button_red.u_released goto released;
      end
      plant automaton button_redgreen:
        location released:
          initial;
          marked;
          edge .shipping_signs.upstream.button_redgreen.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.upstream.button_redgreen.u_released goto released;
      end
      plant automaton button_green:
        location released:
          initial;
          marked;
          edge .shipping_signs.upstream.button_green.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.upstream.button_green.u_released goto released;
      end
      plant automaton button_redred:
        location released:
          initial;
          marked;
          edge .shipping_signs.upstream.button_redred.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.upstream.button_redred.u_released goto released;
      end
      group N:
        alg bool RedOrRedRed = A.red and S_red or A.redred and S_redred;
        alg bool S_red = S_R.on and S_G.off and S_S.off;
        alg bool S_green = S_R.off and S_G.on and S_S.off;
        alg bool S_redgreen = S_R.on and S_G.on and S_S.off;
        alg bool S_redred = S_R.on and S_G.off and S_S.on;
        plant automaton A:
          location red:
            initial;
            marked;
            edge .shipping_signs.upstream.N.c_redred goto redred;
            edge .shipping_signs.upstream.N.c_redgreen goto redgreen;
          location redred:
            marked;
            edge .shipping_signs.upstream.N.c_red goto red;
          location redgreen:
            edge .shipping_signs.upstream.N.c_red goto red;
            edge .shipping_signs.upstream.N.c_green goto green;
          location green:
            edge .shipping_signs.upstream.N.c_red goto red;
        end
        plant automaton S_R:
          alg bool init_on = true;
          alg bool mark_on = true;
          alg bool mark_off = false;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.upstream.N.u_red_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.upstream.N.u_red_off goto off;
        end
        plant automaton S_G:
          alg bool init_on = false;
          alg bool mark_on = false;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.upstream.N.u_green_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.upstream.N.u_green_off goto off;
        end
        plant automaton S_S:
          alg bool init_on = false;
          alg bool mark_on = true;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.upstream.N.u_red2_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.upstream.N.u_red2_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .shipping_signs.upstream.N.u_red_on when A.red or A.redgreen or A.redred;
            edge .shipping_signs.upstream.N.u_red_off when A.green;
            edge .shipping_signs.upstream.N.u_green_on when A.green or A.redgreen;
            edge .shipping_signs.upstream.N.u_green_off when A.red or A.redred;
            edge .shipping_signs.upstream.N.u_red2_on when A.redred;
            edge .shipping_signs.upstream.N.u_red2_off when A.red or A.redgreen or A.green;
        end
      end
      group S:
        alg bool RedOrRedRed = A.red and S_red or A.redred and S_redred;
        alg bool S_red = S_R.on and S_G.off and S_S.off;
        alg bool S_green = S_R.off and S_G.on and S_S.off;
        alg bool S_redgreen = S_R.on and S_G.on and S_S.off;
        alg bool S_redred = S_R.on and S_G.off and S_S.on;
        plant automaton A:
          location red:
            initial;
            marked;
            edge .shipping_signs.upstream.S.c_redred goto redred;
            edge .shipping_signs.upstream.S.c_redgreen goto redgreen;
          location redred:
            marked;
            edge .shipping_signs.upstream.S.c_red goto red;
          location redgreen:
            edge .shipping_signs.upstream.S.c_red goto red;
            edge .shipping_signs.upstream.S.c_green goto green;
          location green:
            edge .shipping_signs.upstream.S.c_red goto red;
        end
        plant automaton S_R:
          alg bool init_on = true;
          alg bool mark_on = true;
          alg bool mark_off = false;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.upstream.S.u_red_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.upstream.S.u_red_off goto off;
        end
        plant automaton S_G:
          alg bool init_on = false;
          alg bool mark_on = false;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.upstream.S.u_green_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.upstream.S.u_green_off goto off;
        end
        plant automaton S_S:
          alg bool init_on = false;
          alg bool mark_on = true;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.upstream.S.u_red2_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.upstream.S.u_red2_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .shipping_signs.upstream.S.u_red_on when A.red or A.redgreen or A.redred;
            edge .shipping_signs.upstream.S.u_red_off when A.green;
            edge .shipping_signs.upstream.S.u_green_on when A.green or A.redgreen;
            edge .shipping_signs.upstream.S.u_green_off when A.red or A.redred;
            edge .shipping_signs.upstream.S.u_red2_on when A.redred;
            edge .shipping_signs.upstream.S.u_red2_off when A.red or A.redgreen or A.green;
        end
      end
    end
    group downstream:
      alg bool RedOrRedRed = N.RedOrRedRed and S.RedOrRedRed;
      alg bool command_rd = button_red.pushed;
      alg bool command_rg = button_redgreen.pushed and not button_red.pushed;
      alg bool command_gn = button_green.pushed and not button_red.pushed and not button_redgreen.pushed;
      alg bool command_sp = button_redred.pushed and not button_red.pushed;
      plant automaton button_red:
        location released:
          initial;
          marked;
          edge .shipping_signs.downstream.button_red.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.downstream.button_red.u_released goto released;
      end
      plant automaton button_redgreen:
        location released:
          initial;
          marked;
          edge .shipping_signs.downstream.button_redgreen.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.downstream.button_redgreen.u_released goto released;
      end
      plant automaton button_green:
        location released:
          initial;
          marked;
          edge .shipping_signs.downstream.button_green.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.downstream.button_green.u_released goto released;
      end
      plant automaton button_redred:
        location released:
          initial;
          marked;
          edge .shipping_signs.downstream.button_redred.u_pushed goto pushed;
        location pushed:
          edge .shipping_signs.downstream.button_redred.u_released goto released;
      end
      group N:
        alg bool RedOrRedRed = A.red and S_red or A.redred and S_redred;
        alg bool S_red = S_R.on and S_G.off and S_S.off;
        alg bool S_green = S_R.off and S_G.on and S_S.off;
        alg bool S_redgreen = S_R.on and S_G.on and S_S.off;
        alg bool S_redred = S_R.on and S_G.off and S_S.on;
        plant automaton A:
          location red:
            initial;
            marked;
            edge .shipping_signs.downstream.N.c_redred goto redred;
            edge .shipping_signs.downstream.N.c_redgreen goto redgreen;
          location redred:
            marked;
            edge .shipping_signs.downstream.N.c_red goto red;
          location redgreen:
            edge .shipping_signs.downstream.N.c_red goto red;
            edge .shipping_signs.downstream.N.c_green goto green;
          location green:
            edge .shipping_signs.downstream.N.c_red goto red;
        end
        plant automaton S_R:
          alg bool init_on = true;
          alg bool mark_on = true;
          alg bool mark_off = false;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.downstream.N.u_red_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.downstream.N.u_red_off goto off;
        end
        plant automaton S_G:
          alg bool init_on = false;
          alg bool mark_on = false;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.downstream.N.u_green_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.downstream.N.u_green_off goto off;
        end
        plant automaton S_S:
          alg bool init_on = false;
          alg bool mark_on = true;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.downstream.N.u_red2_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.downstream.N.u_red2_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .shipping_signs.downstream.N.u_red_on when A.red or A.redgreen or A.redred;
            edge .shipping_signs.downstream.N.u_red_off when A.green;
            edge .shipping_signs.downstream.N.u_green_on when A.green or A.redgreen;
            edge .shipping_signs.downstream.N.u_green_off when A.red or A.redred;
            edge .shipping_signs.downstream.N.u_red2_on when A.redred;
            edge .shipping_signs.downstream.N.u_red2_off when A.red or A.redgreen or A.green;
        end
      end
      group S:
        alg bool RedOrRedRed = A.red and S_red or A.redred and S_redred;
        alg bool S_red = S_R.on and S_G.off and S_S.off;
        alg bool S_green = S_R.off and S_G.on and S_S.off;
        alg bool S_redgreen = S_R.on and S_G.on and S_S.off;
        alg bool S_redred = S_R.on and S_G.off and S_S.on;
        plant automaton A:
          location red:
            initial;
            marked;
            edge .shipping_signs.downstream.S.c_redred goto redred;
            edge .shipping_signs.downstream.S.c_redgreen goto redgreen;
          location redred:
            marked;
            edge .shipping_signs.downstream.S.c_red goto red;
          location redgreen:
            edge .shipping_signs.downstream.S.c_red goto red;
            edge .shipping_signs.downstream.S.c_green goto green;
          location green:
            edge .shipping_signs.downstream.S.c_red goto red;
        end
        plant automaton S_R:
          alg bool init_on = true;
          alg bool mark_on = true;
          alg bool mark_off = false;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.downstream.S.u_red_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.downstream.S.u_red_off goto off;
        end
        plant automaton S_G:
          alg bool init_on = false;
          alg bool mark_on = false;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.downstream.S.u_green_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.downstream.S.u_green_off goto off;
        end
        plant automaton S_S:
          alg bool init_on = false;
          alg bool mark_on = true;
          alg bool mark_off = true;
          location off:
            initial not init_on;
            marked mark_off;
            edge .shipping_signs.downstream.S.u_red2_on goto on;
          location on:
            initial init_on;
            marked mark_on;
            edge .shipping_signs.downstream.S.u_red2_off goto off;
        end
        plant automaton NominalDynamics:
          location:
            initial;
            marked;
            edge .shipping_signs.downstream.S.u_red_on when A.red or A.redgreen or A.redred;
            edge .shipping_signs.downstream.S.u_red_off when A.green;
            edge .shipping_signs.downstream.S.u_green_on when A.green or A.redgreen;
            edge .shipping_signs.downstream.S.u_green_off when A.red or A.redred;
            edge .shipping_signs.downstream.S.u_red2_on when A.redred;
            edge .shipping_signs.downstream.S.u_red2_off when A.red or A.redgreen or A.green;
        end
      end
    end
  end
  group bridgedeck:
    alg bool command_open = button_open.pushed and not button_stop.pushed and not button_close.pushed;
    alg bool command_close = button_close.pushed and not button_stop.pushed;
    alg bool command_stop = button_stop.pushed;
    alg bool bridgedeck_up = S.up and A.stopped;
    alg bool bridgedeck_closed = S.closed and A.stopped;
    alg bool f_bridge = FTC.D.bridge_f;
    plant automaton button_open:
      location released:
        initial;
        marked;
        edge .bridgedeck.button_open.u_pushed goto pushed;
      location pushed:
        edge .bridgedeck.button_open.u_released goto released;
    end
    plant automaton button_stop:
      location released:
        initial;
        marked;
        edge .bridgedeck.button_stop.u_pushed goto pushed;
      location pushed:
        edge .bridgedeck.button_stop.u_released goto released;
    end
    plant automaton button_close:
      location released:
        initial;
        marked;
        edge .bridgedeck.button_close.u_pushed goto pushed;
      location pushed:
        edge .bridgedeck.button_close.u_released goto released;
    end
    plant automaton A:
      location stopped:
        initial;
        marked;
        edge .bridgedeck.c_open goto opening;
        edge .bridgedeck.c_close goto closing;
      location opening:
        edge .bridgedeck.c_stop goto stopped;
      location closing:
        edge .bridgedeck.c_stop goto stopped;
    end
    plant automaton S:
      location closed:
        initial;
        marked;
        edge .bridgedeck.u_closed_off goto between;
      location between:
        edge .bridgedeck.u_open_on goto up;
        edge .bridgedeck.u_closed_on goto closed;
      location up:
        edge .bridgedeck.u_open_off goto between;
    end
    plant automaton NominalDynamics:
      location:
        initial;
        marked;
        edge .bridgedeck.u_closed_off when not f_bridge => A.opening;
        edge .bridgedeck.u_closed_on when not f_bridge => A.closing;
        edge .bridgedeck.u_open_on when not f_bridge => A.opening;
        edge .bridgedeck.u_open_off when not f_bridge => A.closing;
    end
    plant automaton PostFaultDynamics:
      location:
        initial;
        marked;
        edge .bridgedeck.u_closed_off when f_bridge => true;
        edge .bridgedeck.u_closed_on when f_bridge => A.closing;
        edge .bridgedeck.u_open_on when f_bridge => A.opening;
        edge .bridgedeck.u_open_off when f_bridge => A.closing;
    end
  end
  group FTC:
    plant automaton D:
      disc bool ps1_f = false;
      disc bool ps2_f = false;
      disc bool ps3_f = false;
      disc bool ps4_f = false;
      disc bool ps5_f = false;
      disc bool ps6_f = false;
      disc bool s1_f = false;
      disc bool s2_f = false;
      disc bool s3_f = false;
      disc bool s4_f = false;
      disc bool s5_f = false;
      disc bool s6_f = false;
      disc bool s7_f = false;
      disc bool s8_f = false;
      disc bool bar1_f = false;
      disc bool bar4_f = false;
      disc bool bar3_f = false;
      disc bool bar2_f = false;
      disc bool bar5_f = false;
      disc bool bar6_f = false;
      disc bool bridge_f = false;
      location a:
        initial;
        marked;
        edge .FTC.D.f1 do ps1_f := true;
        edge .FTC.D.f2 do ps2_f := true;
        edge .FTC.D.f3 do ps3_f := true;
        edge .FTC.D.f4 do ps4_f := true;
        edge .FTC.D.f5 do ps5_f := true;
        edge .FTC.D.f6 do ps6_f := true;
        edge .FTC.D.f7 do s1_f := true;
        edge .FTC.D.f8 do s2_f := true;
        edge .FTC.D.f9 do s3_f := true;
        edge .FTC.D.f10 do s4_f := true;
        edge .FTC.D.f11 do s5_f := true;
        edge .FTC.D.f12 do s6_f := true;
        edge .FTC.D.f13 do s7_f := true;
        edge .FTC.D.f14 do s8_f := true;
        edge .FTC.D.f15 do bar1_f := true;
        edge .FTC.D.r15 do bar1_f := false;
        edge .FTC.D.f16 do bar4_f := true;
        edge .FTC.D.r16 do bar4_f := false;
        edge .FTC.D.f17 do bar3_f := true;
        edge .FTC.D.r17 do bar3_f := false;
        edge .FTC.D.f18 do bar2_f := true;
        edge .FTC.D.r18 do bar2_f := false;
        edge .FTC.D.f19 do bar5_f := true;
        edge .FTC.D.r19 do bar5_f := false;
        edge .FTC.D.f20 do bar6_f := true;
        edge .FTC.D.r20 do bar6_f := false;
        edge .FTC.D.f25 do bridge_f := true;
    end
  end
  supervisor automaton sup:
    alphabet .LTS.presigns.ps1.c_on, .LTS.presigns.ps1.c_off, .LTS.presigns.ps2.c_on, .LTS.presigns.ps2.c_off, .LTS.presigns.ps3.c_on, .LTS.presigns.ps3.c_off, .LTS.presigns.ps4.c_on, .LTS.presigns.ps4.c_off, .LTS.presigns.ps5.c_on, .LTS.presigns.ps5.c_off, .LTS.presigns.ps6.c_on, .LTS.presigns.ps6.c_off, .LTS.stopsigns.stop1.c_on, .LTS.stopsigns.stop1.c_off, .LTS.stopsigns.stop2.c_on, .LTS.stopsigns.stop2.c_off, .LTS.stopsigns.stop3.c_on, .LTS.stopsigns.stop3.c_off, .LTS.stopsigns.stop4.c_on, .LTS.stopsigns.stop4.c_off, .LTS.stopsigns.stop5.c_on, .LTS.stopsigns.stop5.c_off, .LTS.stopsigns.stop6.c_on, .LTS.stopsigns.stop6.c_off, .LTS.stopsigns.stop7.c_on, .LTS.stopsigns.stop7.c_off, .LTS.stopsigns.stop8.c_on, .LTS.stopsigns.stop8.c_off, .barriers.barrier1.c_open, .barriers.barrier1.c_close, .barriers.barrier1.c_stop, .barriers.barrier2.c_open, .barriers.barrier2.c_close, .barriers.barrier2.c_stop, .barriers.barrier3.c_open, .barriers.barrier3.c_close, .barriers.barrier3.c_stop, .barriers.barrier4.c_open, .barriers.barrier4.c_close, .barriers.barrier4.c_stop, .barriers.barrier5.c_open, .barriers.barrier5.c_close, .barriers.barrier5.c_stop, .barriers.barrier6.c_open, .barriers.barrier6.c_close, .barriers.barrier6.c_stop, .shipping_signs.upstream.N.c_redred, .shipping_signs.upstream.N.c_redgreen, .shipping_signs.upstream.N.c_red, .shipping_signs.upstream.N.c_green, .shipping_signs.upstream.S.c_redred, .shipping_signs.upstream.S.c_redgreen, .shipping_signs.upstream.S.c_red, .shipping_signs.upstream.S.c_green, .shipping_signs.downstream.N.c_redred, .shipping_signs.downstream.N.c_redgreen, .shipping_signs.downstream.N.c_red, .shipping_signs.downstream.N.c_green, .shipping_signs.downstream.S.c_redred, .shipping_signs.downstream.S.c_redgreen, .shipping_signs.downstream.S.c_red, .shipping_signs.downstream.S.c_green, .bridgedeck.c_open, .bridgedeck.c_close, .bridgedeck.c_stop;
    location:
      initial;
      marked;
      edge .barriers.barrier1.c_close when true;
      edge .barriers.barrier1.c_open when true;
      edge .barriers.barrier1.c_stop when true;
      edge .barriers.barrier2.c_close when true;
      edge .barriers.barrier2.c_open when true;
      edge .barriers.barrier2.c_stop when true;
      edge .barriers.barrier3.c_close when true;
      edge .barriers.barrier3.c_open when true;
      edge .barriers.barrier3.c_stop when true;
      edge .barriers.barrier4.c_close when true;
      edge .barriers.barrier4.c_open when true;
      edge .barriers.barrier4.c_stop when true;
      edge .barriers.barrier5.c_close when true;
      edge .barriers.barrier5.c_open when true;
      edge .barriers.barrier5.c_stop when true;
      edge .barriers.barrier6.c_close when true;
      edge .barriers.barrier6.c_open when true;
      edge .barriers.barrier6.c_stop when true;
      edge .bridgedeck.c_close when true;
      edge .bridgedeck.c_open when true;
      edge .bridgedeck.c_stop when true;
      edge .LTS.presigns.ps1.c_off when true;
      edge .LTS.presigns.ps1.c_on when true;
      edge .LTS.presigns.ps2.c_off when true;
      edge .LTS.presigns.ps2.c_on when true;
      edge .LTS.presigns.ps3.c_off when true;
      edge .LTS.presigns.ps3.c_on when true;
      edge .LTS.presigns.ps4.c_off when true;
      edge .LTS.presigns.ps4.c_on when true;
      edge .LTS.presigns.ps5.c_off when true;
      edge .LTS.presigns.ps5.c_on when true;
      edge .LTS.presigns.ps6.c_off when true;
      edge .LTS.presigns.ps6.c_on when true;
      edge .LTS.stopsigns.stop1.c_off when true;
      edge .LTS.stopsigns.stop1.c_on when true;
      edge .LTS.stopsigns.stop2.c_off when true;
      edge .LTS.stopsigns.stop2.c_on when true;
      edge .LTS.stopsigns.stop3.c_off when true;
      edge .LTS.stopsigns.stop3.c_on when true;
      edge .LTS.stopsigns.stop4.c_off when true;
      edge .LTS.stopsigns.stop4.c_on when true;
      edge .LTS.stopsigns.stop5.c_off when true;
      edge .LTS.stopsigns.stop5.c_on when true;
      edge .LTS.stopsigns.stop6.c_off when true;
      edge .LTS.stopsigns.stop6.c_on when true;
      edge .LTS.stopsigns.stop7.c_off when true;
      edge .LTS.stopsigns.stop7.c_on when true;
      edge .LTS.stopsigns.stop8.c_off when true;
      edge .LTS.stopsigns.stop8.c_on when true;
      edge .shipping_signs.downstream.N.c_green when true;
      edge .shipping_signs.downstream.N.c_red when true;
      edge .shipping_signs.downstream.N.c_redgreen when true;
      edge .shipping_signs.downstream.N.c_redred when true;
      edge .shipping_signs.downstream.S.c_green when true;
      edge .shipping_signs.downstream.S.c_red when true;
      edge .shipping_signs.downstream.S.c_redgreen when true;
      edge .shipping_signs.downstream.S.c_redred when true;
      edge .shipping_signs.upstream.N.c_green when true;
      edge .shipping_signs.upstream.N.c_red when true;
      edge .shipping_signs.upstream.N.c_redgreen when true;
      edge .shipping_signs.upstream.N.c_redred when true;
      edge .shipping_signs.upstream.S.c_green when true;
      edge .shipping_signs.upstream.S.c_red when true;
      edge .shipping_signs.upstream.S.c_redgreen when true;
      edge .shipping_signs.upstream.S.c_redred when true;
  end
end
group button_LTS_on:
  alg string svginid = "button1";
  alg string svgoutid = "button1V";
  alg bool pushed = LTS.button_on.pushed;
  svgin id svginid event if pushed: LTS.button_on.u_released else LTS.button_on.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_entering_barriers_CK_close:
  alg string svginid = "button2";
  alg string svgoutid = "button2V";
  alg bool pushed = barriers.button_close_entering.pushed;
  svgin id svginid event if pushed: barriers.button_close_entering.u_released else barriers.button_close_entering.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_entering_barriers_CK_open:
  alg string svginid = "button3";
  alg string svgoutid = "button3V";
  alg bool pushed = barriers.button_open_entering.pushed;
  svgin id svginid event if pushed: barriers.button_open_entering.u_released else barriers.button_open_entering.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_entering_barriers_CK_stop:
  alg string svginid = "button4";
  alg string svgoutid = "button4V";
  alg bool pushed = barriers.button_stop_entering.pushed;
  svgin id svginid event if pushed: barriers.button_stop_entering.u_released else barriers.button_stop_entering.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_leaving_barriers_CK_close:
  alg string svginid = "button5";
  alg string svgoutid = "button5V";
  alg bool pushed = barriers.button_close_leaving.pushed;
  svgin id svginid event if pushed: barriers.button_close_leaving.u_released else barriers.button_close_leaving.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_leaving_barriers_CK_open:
  alg string svginid = "button6";
  alg string svgoutid = "button6V";
  alg bool pushed = barriers.button_open_leaving.pushed;
  svgin id svginid event if pushed: barriers.button_open_leaving.u_released else barriers.button_open_leaving.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_leaving_barriers_CK_stop:
  alg string svginid = "button7";
  alg string svgoutid = "button7V";
  alg bool pushed = barriers.button_stop_leaving.pushed;
  svgin id svginid event if pushed: barriers.button_stop_leaving.u_released else barriers.button_stop_leaving.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_slow_barriers_CK_close:
  alg string svginid = "button14";
  alg string svgoutid = "button14V";
  alg bool pushed = barriers.button_close_slow.pushed;
  svgin id svginid event if pushed: barriers.button_close_slow.u_released else barriers.button_close_slow.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_slow_barriers_CK_open:
  alg string svginid = "button15";
  alg string svgoutid = "button15V";
  alg bool pushed = barriers.button_open_slow.pushed;
  svgin id svginid event if pushed: barriers.button_open_slow.u_released else barriers.button_open_slow.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_slow_barriers_CK_stop:
  alg string svginid = "button16";
  alg string svgoutid = "button16V";
  alg bool pushed = barriers.button_stop_slow.pushed;
  svgin id svginid event if pushed: barriers.button_stop_slow.u_released else barriers.button_stop_slow.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_bridge_open:
  alg string svginid = "button17";
  alg string svgoutid = "button17V";
  alg bool pushed = bridgedeck.button_open.pushed;
  svgin id svginid event if pushed: bridgedeck.button_open.u_released else bridgedeck.button_open.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_bridge_close:
  alg string svginid = "button18";
  alg string svgoutid = "button18V";
  alg bool pushed = bridgedeck.button_close.pushed;
  svgin id svginid event if pushed: bridgedeck.button_close.u_released else bridgedeck.button_close.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_bridge_stop:
  alg string svginid = "button19";
  alg string svgoutid = "button19V";
  alg bool pushed = bridgedeck.button_stop.pushed;
  svgin id svginid event if pushed: bridgedeck.button_stop.u_released else bridgedeck.button_stop.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_upstream_rd:
  alg string svginid = "button20";
  alg string svgoutid = "button20V";
  alg bool pushed = shipping_signs.upstream.button_red.pushed;
  svgin id svginid event if pushed: shipping_signs.upstream.button_red.u_released else shipping_signs.upstream.button_red.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_upstream_gn:
  alg string svginid = "button21";
  alg string svgoutid = "button21V";
  alg bool pushed = shipping_signs.upstream.button_green.pushed;
  svgin id svginid event if pushed: shipping_signs.upstream.button_green.u_released else shipping_signs.upstream.button_green.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_upstream_rdgn:
  alg string svginid = "button22";
  alg string svgoutid = "button22V";
  alg bool pushed = shipping_signs.upstream.button_redgreen.pushed;
  svgin id svginid event if pushed: shipping_signs.upstream.button_redgreen.u_released else shipping_signs.upstream.button_redgreen.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_downstream_rd:
  alg string svginid = "button23";
  alg string svgoutid = "button23V";
  alg bool pushed = shipping_signs.downstream.button_red.pushed;
  svgin id svginid event if pushed: shipping_signs.downstream.button_red.u_released else shipping_signs.downstream.button_red.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_downstream_gn:
  alg string svginid = "button24";
  alg string svgoutid = "button24V";
  alg bool pushed = shipping_signs.downstream.button_green.pushed;
  svgin id svginid event if pushed: shipping_signs.downstream.button_green.u_released else shipping_signs.downstream.button_green.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_downstream_rdgn:
  alg string svginid = "button25";
  alg string svgoutid = "button25V";
  alg bool pushed = shipping_signs.downstream.button_redgreen.pushed;
  svgin id svginid event if pushed: shipping_signs.downstream.button_redgreen.u_released else shipping_signs.downstream.button_redgreen.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_upstream_sp:
  alg string svginid = "button26";
  alg string svgoutid = "button26V";
  alg bool pushed = shipping_signs.upstream.button_redred.pushed;
  svgin id svginid event if pushed: shipping_signs.upstream.button_redred.u_released else shipping_signs.upstream.button_redred.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group button_downstream_sp:
  alg string svginid = "button27";
  alg string svgoutid = "button27V";
  alg bool pushed = shipping_signs.downstream.button_redred.pushed;
  svgin id svginid event if pushed: shipping_signs.downstream.button_redred.u_released else shipping_signs.downstream.button_redred.u_pushed end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "fill" value if pushed: "yellowgreen" else "indianred" end file "../e_svg_visualization.svg";
end
group presign_C_100:
  alg string svgoutid = "presign1";
  alg string color = "orange";
  alg bool on = LTS.presigns.ps1.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group presign_C_200:
  alg string svgoutid = "presign2";
  alg string color = "orange";
  alg bool on = LTS.presigns.ps2.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group presign_C_500:
  alg string svgoutid = "presign3";
  alg string color = "orange";
  alg bool on = LTS.presigns.ps3.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group presign_K_150:
  alg string svgoutid = "presign4";
  alg string color = "orange";
  alg bool on = LTS.presigns.ps4.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group presign_K_250:
  alg string svgoutid = "presign5";
  alg string color = "orange";
  alg bool on = LTS.presigns.ps5.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group presign_K_300:
  alg string svgoutid = "presign6";
  alg string color = "orange";
  alg bool on = LTS.presigns.ps6.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign5:
  alg string svgoutid = "stopsign1";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop1.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign6:
  alg string svgoutid = "stopsign2";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop2.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign7:
  alg string svgoutid = "stopsign3";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop3.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign8:
  alg string svgoutid = "stopsign4";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop4.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign9:
  alg string svgoutid = "stopsign5";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop5.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign10:
  alg string svgoutid = "stopsign6";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop6.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign11:
  alg string svgoutid = "stopsign7";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop7.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group stopsign12:
  alg string svgoutid = "stopsign8";
  alg string color = "red";
  alg bool on = LTS.stopsigns.stop8.S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit1:
  alg string svgoutid = "shippingsign_downstream_l_r";
  alg string color = "red";
  alg bool on = shipping_signs.downstream.N.S_R.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit2:
  alg string svgoutid = "shippingsign_downstream_l_g";
  alg string color = "green";
  alg bool on = shipping_signs.downstream.N.S_G.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit2b:
  alg string svgoutid = "shippingsign_downstream_l_s";
  alg string color = "red";
  alg bool on = shipping_signs.downstream.N.S_S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit3:
  alg string svgoutid = "shippingsign_downstream_r_r";
  alg string color = "red";
  alg bool on = shipping_signs.downstream.S.S_R.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit4:
  alg string svgoutid = "shippingsign_downstream_r_g";
  alg string color = "green";
  alg bool on = shipping_signs.downstream.S.S_G.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit4b:
  alg string svgoutid = "shippingsign_downstream_r_s";
  alg string color = "red";
  alg bool on = shipping_signs.downstream.S.S_S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit5:
  alg string svgoutid = "shippingsign_upstream_l_r";
  alg string color = "red";
  alg bool on = shipping_signs.upstream.N.S_R.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit6:
  alg string svgoutid = "shippingsign_upstream_l_g";
  alg string color = "green";
  alg bool on = shipping_signs.upstream.N.S_G.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit6b:
  alg string svgoutid = "shippingsign_upstream_l_s";
  alg string color = "red";
  alg bool on = shipping_signs.upstream.N.S_S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit7:
  alg string svgoutid = "shippingsign_upstream_r_r";
  alg string color = "red";
  alg bool on = shipping_signs.upstream.S.S_R.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit8:
  alg string svgoutid = "shippingsign_upstream_r_g";
  alg string color = "green";
  alg bool on = shipping_signs.upstream.S.S_G.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group uit8b:
  alg string svgoutid = "shippingsign_upstream_r_s";
  alg string color = "red";
  alg bool on = shipping_signs.upstream.S.S_S.o;
  svgout id svgoutid attr "fill" value if on: color else "grey" end file "../e_svg_visualization.svg";
end
group barrier1f:
  alg string svgoutid = "barrier1f";
  alg bool b = barriers.barrier1.S.c;
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier1m:
  alg string svgoutid = "barrier1m";
  alg bool b = not(barriers.barrier1.S.c or barriers.barrier1.S.o);
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier3f:
  alg string svgoutid = "barrier3f";
  alg bool b = barriers.barrier5.S.c;
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier3m:
  alg string svgoutid = "barrier3m";
  alg bool b = not(barriers.barrier5.S.c or barriers.barrier5.S.o);
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier4f:
  alg string svgoutid = "barrier4f";
  alg bool b = barriers.barrier3.S.c;
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier4m:
  alg string svgoutid = "barrier4m";
  alg bool b = not(barriers.barrier3.S.c or barriers.barrier3.S.o);
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier6f:
  alg string svgoutid = "barrier6f";
  alg bool b = barriers.barrier2.S.c;
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier6m:
  alg string svgoutid = "barrier6m";
  alg bool b = not(barriers.barrier2.S.c or barriers.barrier2.S.o);
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier7f:
  alg string svgoutid = "barrier7f";
  alg bool b = barriers.barrier4.S.c;
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier7m:
  alg string svgoutid = "barrier7m";
  alg bool b = not(barriers.barrier4.S.c or barriers.barrier4.S.o);
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier8f:
  alg string svgoutid = "barrier8f";
  alg bool b = barriers.barrier6.S.c;
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group barrier8m:
  alg string svgoutid = "barrier8m";
  alg bool b = not(barriers.barrier6.S.c or barriers.barrier6.S.o);
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id svgoutid attr "fill-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id svgoutid attr "stroke-opacity" value if b: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
group deck1:
  alg string b = "bridgedeck_KC";
  alg string c = "bridgedeck_CK";
  alg string d = "bridgedeck_bike";
  alg string e = "bridgedeck_pedestrian";
  alg string h = "arrow_KC";
  alg string i = "arrow_CK";
  alg string j = "arrow_bike_left";
  alg string k = "arrow_bike_right";
  alg string l = "arrow_pedestrian_left";
  alg string m = "arrow_pedestrian_right";
  alg bool closed = bridgedeck.position.c;
  alg real opacity_closed = 100.0;
  alg real opacity_opened = 0.0;
  svgout id b attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id c attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id d attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id e attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id h attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id i attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id j attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id k attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id l attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id m attr "fill-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id b attr "stroke-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id c attr "stroke-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id d attr "stroke-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
  svgout id e attr "stroke-opacity" value if closed: opacity_closed else opacity_opened end file "../e_svg_visualization.svg";
end
